# 命令

* [返回上层目录](../shell.md)



# 比较命令

## 数值比较

| 运算符                  | 描述                                   | 示例                                            |
| ----------------------- | -------------------------------------- | ----------------------------------------------- |
| num1 -eq num2 | 等于       | [ 3 -eq $mynum ] |
| num1 -ne num2 | 不等于     | [ 3 -ne $mynum ] |
| num1 -lt num2 | 小于       | [ 3 -lt $mynum ] |
| num1 -le num2 | 小于或等于 | [ 3 -le $mynum ] |
| num1 -gt num2 | 大于       | [ 3 -gt $mynum ] |
| num1 -ge num2 | 大于或等于 | [ 3 -ge $mynum ] |

## 字符串比较

| 运算符                  | 描述                                   | 示例                                            |
| ----------------------- | -------------------------------------- | ----------------------------------------------- |
| -z string          | 如果 string 长度为零，则为真         | [ -z "$myvar" ]                 |
| -n string          | 如果 string 长度非零，则为真         | [ -n "$myvar" ]                 |
| string1 = string2  | 如果 string1 与 string2 相同，则为真 | [ "$myvar" = "one two three" ]  |
| string1 != string2 | 如果 string1 与 string2 不同，则为真 | [ "$myvar" != "one two three" ] |

## 文件比较

| 运算符                  | 描述                                   | 示例                                            |
| ----------------------- | -------------------------------------- | ----------------------------------------------- |
| -e filename             | 如果 filename 存在，则为真             | [ -e /var/log/syslog ]                          |
| -d filename             | 如果 filename 为目录，则为真           | [ -d /tmp/mydir ]                               |
| -f filename             | 如果 filename 为常规文件，则为真       | [ -f /usr/bin/grep ]                            |
| -L filename             | 如果 filename 为符号链接，则为真       | [ -L /usr/bin/grep ]                            |
| -r filename             | 如果 filename 可读，则为真             | [ -r /var/log/syslog ]                          |
| -w filename             | 如果 filename 可写，则为真             | [ -w /var/mytmp.txt ]                           |
| -x filename             | 如果 filename 可执行，则为真           | [ -L /usr/bin/grep ]                            |
| filename1 -nt filename2 | 如果 filename1 比 filename2 新，则为真 | [ /tmp/install/etc/services -nt /etc/services ] |
| filename1 -ot filename2 | 如果 filename1 比 filename2 旧，则为真 | [ /boot/bzImage -ot arch/i386/boot/bzImage ]    |

## 逻辑操作符

另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为："!"最高，"-a"次之，"-o"最低。例如：

```shell
cd /bin
if test -e ./notFile -o -e ./bash
then
    echo '至少有一个文件存在!'
else
    echo '两个文件都不存在'
fi
```



# test命令

Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。

分别举例如下：

* 数值测试

  ```shell
  num1=100
  num2=100
  if test $[num1] -eq $[num2]
  then
      echo '两个数相等！'
  else
      echo '两个数不相等！'
  fi
  ```

  输出结果：

  ```shell
  两个数相等！
  ```

* 字符串测试

  ```shell
  num1="ru1noob"
  num2="runoob"
  if test $num1 = $num2
  then
      echo '两个字符串相等!'
  else
      echo '两个字符串不相等!'
  fi
  ```

  输出结果：

  ```shell
  两个字符串不相等!
  ```

* 文件测试

  ```shell
  cd /bin
  if test -e ./bash
  then
      echo '文件已存在!'
  else
      echo '文件不存在!'
  fi
  ```

  输出结果：

  ```shell
  文件已存在!
  ```

## `[[]]`和`[ ]`区别

学习shell的时候总是被shell里的条件判断方式搞得头疼，经常不知道改 用``[]``，`[[]]`，`(())`还是`test`，`let`，而很少有书把它们的关系讲解的很清楚(应该是我悟性差或是看书太少)，今天总结一下，基础的东西如它们 的使用方法不再赘述，重点说说它们的区别的使用时应该注意的地方。

- `[]`和`test`

  先说**`[]`和`test`，两者是一样的**，在命令行里`test expr`和`[ expr ]`的效果相同。`test`的三个基本作用是判断文件、判断字符串、判断整数。支持使用与或非将表达式连接起来。要注意的有：

  `test`中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq, -gt这种形式。无论是字符串比较还是整数比较都千万不要使用大于号小于号。当然，如果你实在想用也是可以的，对于字符串比较可以使用尖括号的转义形式， 如果比较"ab"和"bc"：`[ ab \< bc ]`，结果为真，也就是返回状态为0。

- `[[ ]]`

  然后是**`[[ ]]`，这是内置在shell中的一个命令**，它就比刚才说的`test`强大的多了。支持字符串的模式匹配（使用=~操作符时甚至支持shell的正则表达式）。简直强大的令人发指！逻辑组合可以不使用`test`的`-a`、`-o`而使用`&&`、`||`这样更亲切的形式(针对c、Java程序员)。当 然，也不用想的太复杂，基本只要记住

  1、字符串比较时可以把右边的作为一个模式（这是右边的字符串不加双引号的情况下。如果右边的字符串加了双引号，则认为是一个文本字符串），而不仅仅是一个字符串，比如`[[ hello == hell? ]]`，结果为真。

  2、使用`[]`和`[[]]`的时候不要吝啬空格，每一项两边都要有空格，`[[ 1 == 2 ]]`的结果为“假”，但`[[ 1==2 ]]`的结果为“真”！后一种显然是错的

- `let`和`(())`

  两者也是一样（或者说基本上是一样的，双括号比`let`稍弱一些）。主要进行算术运算（上面的两个都不行），也比较适合进 行整数比较，可以直接使用熟悉的<,>等比较运算符。可以直接使用变量名如var而不需要$var这样的形式。支持分号隔开的多个表达式

**`[[ ]]`和`[ ]`区别**

- 首先，尽管很相似，但是从概念上讲，二者是不同层次的东西。

  `[[`是关键字，许多shell(如ash bsh)并不支持这种方式。ksh, bash（据说从2.02起引入对``[[``的支持）等支持。

  `[`是一条命令， 与`test`等价，大多数shell都支持。在现代的大多数sh实现中，`[`与`test`是内部(builtin)命令，换句话说执行`test`或`[`时不会调用/some/path/to/test这样的外部命令（如果有这样的命令的话）。

- `[[]]`结构比Bash版本的`[]`更通用。在`[[`和`]]`之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。

  用`[[ ... ]]`测试结构比用`[ ... ]`更能防止脚本里的许多逻辑错误。比如说，`&&`,`||`,`<`和`>`操作符能在一个`[[]]`测试里通过，但在`[]`结构会发生错误。

- `(( ))`结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前`test`命令及`[]`结构的讨论刚好相反。

- `[ ]`为shell命令，所以在其中的表达式应是它的命令行参数，所以串比较操作符`>` 与`<`必须转义，否则就变成IO改向操作符了(请参看上面2中的例子)。在`[[`中`<`与`>`不需转义；
  由于`[[`是关键字，不会做命令行扩展，因而相对的语法就稍严格些。例如
  在`[ ]`中可以用引号括起操作符，因为在做命令行扩展时会去掉这些引号，而在`[[ ]]`则不允许这样做。

- `[[ ]]`进行算术扩展，而`[ ]`不做







# 参考资料

* [shell中if条件字符串、数字比对，[[ \]]和[ ]区别](https://www.cnblogs.com/include/archive/2011/12/09/2307905.html)

"比较命令"参考此资料。

* [Shell test 命令](https://www.runoob.com/linux/linux-shell-test.html)
* [shell中if条件字符串、数字比对，[[ \]]和[ ]区别](https://www.cnblogs.com/include/archive/2011/12/09/2307905.html)

"test命令"参考此资料。
